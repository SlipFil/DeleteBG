import {useMemo as $cAn5f$useMemo, useEffect as $cAn5f$useEffect} from "react";
import {useMultipleSelectionState as $cAn5f$useMultipleSelectionState, SelectionManager as $cAn5f$SelectionManager} from "@react-stately/selection";

function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $62967d126f3aa823$exports = {};

$parcel$export($62967d126f3aa823$exports, "useGridState", () => $62967d126f3aa823$export$4007ac09ff9c68ed);


function $62967d126f3aa823$export$4007ac09ff9c68ed(props) {
    let { collection: collection , focusMode: focusMode  } = props;
    let selectionState = $cAn5f$useMultipleSelectionState(props);
    let disabledKeys = $cAn5f$useMemo(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set()
    , [
        props.disabledKeys
    ]);
    let setFocusedKey = selectionState.setFocusedKey;
    selectionState.setFocusedKey = (key, child)=>{
        // If focusMode is cell and an item is focused, focus a child cell instead.
        if (focusMode === 'cell' && key != null) {
            let item = collection.getItem(key);
            if ((item === null || item === void 0 ? void 0 : item.type) === 'item') {
                var ref, ref1;
                let children = [
                    ...item.childNodes
                ];
                if (child === 'last') key = (ref = children[children.length - 1]) === null || ref === void 0 ? void 0 : ref.key;
                else key = (ref1 = children[0]) === null || ref1 === void 0 ? void 0 : ref1.key;
            }
        }
        setFocusedKey(key, child);
    };
    // Reset focused key if that item is deleted from the collection.
    $cAn5f$useEffect(()=>{
        if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) selectionState.setFocusedKey(null);
    }, [
        collection,
        selectionState.focusedKey
    ]);
    return {
        collection: collection,
        disabledKeys: disabledKeys,
        selectionManager: new $cAn5f$SelectionManager(collection, selectionState)
    };
}


var $16805b1b18093c5f$exports = {};

$parcel$export($16805b1b18093c5f$exports, "GridCollection", () => $16805b1b18093c5f$export$de3fdf6493c353d);
var tmp = Symbol.iterator;
class $16805b1b18093c5f$export$de3fdf6493c353d {
    *[tmp]() {
        yield* [
            ...this.rows
        ];
    }
    get size() {
        return [
            ...this.rows
        ].length;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        let node = this.keyMap.get(key);
        return node ? node.prevKey : null;
    }
    getKeyAfter(key) {
        let node = this.keyMap.get(key);
        return node ? node.nextKey : null;
    }
    getFirstKey() {
        var ref;
        return (ref = [
            ...this.rows
        ][0]) === null || ref === void 0 ? void 0 : ref.key;
    }
    getLastKey() {
        var ref;
        let rows = [
            ...this.rows
        ];
        return (ref = rows[rows.length - 1]) === null || ref === void 0 ? void 0 : ref.key;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
    at(idx) {
        const keys = [
            ...this.getKeys()
        ];
        return this.getItem(keys[idx]);
    }
    constructor(opts){
        this.keyMap = new Map();
        this.keyMap = new Map();
        this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;
        this.rows = [];
        let visit = (node)=>{
            // If the node is the same object as the previous node for the same key,
            // we can skip this node and its children. We always visit columns though,
            // because we depend on order to build the columns array.
            let prevNode = this.keyMap.get(node.key);
            if (opts.visitNode) node = opts.visitNode(node);
            this.keyMap.set(node.key, node);
            let childKeys = new Set();
            let last;
            for (let child of node.childNodes){
                if (child.type === 'cell' && child.parentKey == null) // if child is a cell parent key isn't already established by the collection, match child node to parent row
                child.parentKey = node.key;
                childKeys.add(child.key);
                if (last) {
                    last.nextKey = child.key;
                    child.prevKey = last.key;
                } else child.prevKey = null;
                visit(child);
                last = child;
            }
            if (last) last.nextKey = null;
            // Remove deleted nodes and their children from the key map
            if (prevNode) {
                for (let child of prevNode.childNodes)if (!childKeys.has(child.key)) remove(child);
            }
        };
        let remove = (node)=>{
            this.keyMap.delete(node.key);
            for (let child of node.childNodes)if (this.keyMap.get(child.key) === child) remove(child);
        };
        let last1;
        opts.items.forEach((node, i)=>{
            let rowNode = {
                level: 0,
                key: 'row-' + i,
                type: 'row',
                value: undefined,
                hasChildNodes: true,
                childNodes: [
                    ...node.childNodes
                ],
                rendered: undefined,
                textValue: undefined,
                ...node,
                index: i
            };
            if (last1) {
                last1.nextKey = rowNode.key;
                rowNode.prevKey = last1.key;
            } else rowNode.prevKey = null;
            this.rows.push(rowNode);
            visit(rowNode);
            last1 = rowNode;
        });
        if (last1) last1.nextKey = null;
    }
}




export {$62967d126f3aa823$export$4007ac09ff9c68ed as useGridState, $16805b1b18093c5f$export$de3fdf6493c353d as GridCollection};
//# sourceMappingURL=module.js.map
