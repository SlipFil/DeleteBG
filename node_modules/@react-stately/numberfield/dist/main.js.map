{"mappings":"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","sources":["packages/@react-stately/numberfield/src/index.ts","packages/@react-stately/numberfield/src/useNumberFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/// <reference types=\"intl-types-extension\" />\n\nexport * from './useNumberFieldState';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {NumberFieldProps} from '@react-types/numberfield';\nimport {NumberFormatter, NumberParser} from '@internationalized/number';\nimport {useCallback, useMemo, useRef, useState} from 'react';\n\nexport interface NumberFieldState {\n  /**\n   * The current text value of the input. Updated as the user types,\n   * and formatted according to `formatOptions` on blur.\n   */\n  inputValue: string,\n  /**\n   * The currently parsed number value, or NaN if a valid number could not be parsed.\n   * Updated based on the `inputValue` as the user types.\n   */\n  numberValue: number,\n  /** The minimum value of the number field. */\n  minValue: number,\n  /** The maximum value of the number field. */\n  maxValue: number,\n  /** Whether the current value can be incremented according to the maximum value and step. */\n  canIncrement: boolean,\n  /** Whether the current value can be decremented according to the minimum value and step. */\n  canDecrement: boolean,\n  /**\n   * Validates a user input string according to the current locale and format options.\n   * Values can be partially entered, and may be valid even if they cannot currently be parsed to a number.\n   * Can be used to implement validation as a user types.\n   */\n  validate(value: string): boolean,\n  /** Sets the current text value of the input. */\n  setInputValue(val: string): void,\n  /**\n   * Commits the current input value. The value is parsed to a number, clamped according\n   * to the minimum and maximum values of the field, and snapped to the nearest step value.\n   * This will fire the `onChange` prop with the new value, and if uncontrolled, update the `numberValue`.\n   * Typically this is called when the field is blurred.\n   */\n  commit(): void,\n  /** Increments the current input value to the next step boundary, and fires `onChange`. */\n  increment(): void,\n  /** Decrements the current input value to the next step boundary, and fires `onChange`. */\n  decrement(): void,\n  /** Sets the current value to the `maxValue` if any, and fires `onChange`. */\n  incrementToMax(): void,\n  /** Sets the current value to the `minValue` if any, and fires `onChange`. */\n  decrementToMin(): void\n}\n\ninterface NumberFieldStateProps extends NumberFieldProps {\n  /**\n   * The locale that should be used for parsing.\n   * @default 'en-US'\n   */\n  locale: string\n}\n\n/**\n * Provides state management for a number field component. Number fields allow users to enter a number,\n * and increment or decrement the value using stepper buttons.\n */\nexport function useNumberFieldState(\n  props: NumberFieldStateProps\n): NumberFieldState {\n  let {\n    minValue,\n    maxValue,\n    step,\n    formatOptions,\n    value,\n    defaultValue,\n    onChange,\n    locale,\n    isDisabled,\n    isReadOnly\n  } = props;\n\n  let [numberValue, setNumberValue] = useControlledState<number>(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = useState(() => isNaN(numberValue) ? '' : new NumberFormatter(locale, formatOptions).format(numberValue));\n\n  let numberParser = useMemo(() => new NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = useMemo(() => new NumberFormatter(locale, {...formatOptions, numberingSystem}), [locale, formatOptions, numberingSystem]);\n  let intlOptions = useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = useCallback((value: number) => isNaN(value) ? '' : formatter.format(value), [formatter]);\n\n  let clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && isNaN(step)) {\n    clampStep = 0.01;\n  }\n\n  // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n  let prevValue = useRef(numberValue);\n  let prevLocale = useRef(locale);\n  let prevFormatOptions = useRef(formatOptions);\n  if (!Object.is(numberValue, prevValue.current) || locale !== prevLocale.current || formatOptions !== prevFormatOptions.current) {\n    setInputValue(format(numberValue));\n    prevValue.current = numberValue;\n    prevLocale.current = locale;\n    prevFormatOptions.current = formatOptions;\n  }\n\n  // Store last parsed value in a ref so it can be used by increment/decrement below\n  let parsedValue = useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let parsed = useRef(0);\n  parsed.current = parsedValue;\n\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? '' : format(numberValue));\n      return;\n    }\n\n    // if it failed to parse, then reset input to formatted version of current number\n    if (isNaN(parsed.current)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n\n    // Clamp to min and max, round to the nearest step, and round to specified number of digits\n    let clampedValue: number;\n    if (isNaN(step)) {\n      clampedValue = clamp(parsed.current, minValue, maxValue);\n    } else {\n      clampedValue = snapValueToStep(parsed.current, minValue, maxValue, step);\n    }\n\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation: '+' | '-', minMax: number) => {\n    let prev = parsed.current;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = snapValueToStep(prev, minValue, maxValue, clampStep);\n      if ((operation === '+' && newValue > prev) || (operation === '-' && newValue < prev)) {\n        return newValue;\n      }\n\n      return snapValueToStep(\n        handleDecimalOperation(operation, prev, clampStep),\n        minValue,\n        maxValue,\n        clampStep\n      );\n    }\n  };\n\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue);\n\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) {\n      setNumberValue(snapValueToStep(maxValue, minValue, maxValue, clampStep));\n    }\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) {\n      setNumberValue(minValue);\n    }\n  };\n\n  let canIncrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(maxValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue ||\n      handleDecimalOperation('+', parsedValue, clampStep) <= maxValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let canDecrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(minValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue ||\n      handleDecimalOperation('-', parsedValue, clampStep) >= minValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = (value: string) => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    validate,\n    increment,\n    incrementToMax,\n    decrement,\n    decrementToMin,\n    canIncrement,\n    canDecrement,\n    minValue,\n    maxValue,\n    numberValue: parsedValue,\n    setInputValue,\n    inputValue,\n    commit\n  };\n}\n\nfunction handleDecimalOperation(operator: '-' | '+', value1: number, value2: number): number {\n  let result = operator === '+' ? value1 + value2 : value1 - value2;\n\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0;\n    const value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2;\n\n    // Transform the integer result back to decimal\n    result /= multiplier;\n  }\n\n  return result;\n}\n"],"names":[],"version":3,"file":"main.js.map"}